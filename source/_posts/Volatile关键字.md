---
title: Volatile关键字
date: 2018-07-28 21:26:13
categories: 
- Java
tags:
- Java
- 多线程
- 同步
---

Java语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独的获取这个变量。如果有一个字段被声明为Volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。

## volatile是如何保证可见性的 ？
在java虚拟机的内存模型中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存的数据，下面看看操作普通变量和volatile变量有什么不同：

1. 对于普通变量：读操作会优先读取工作内存的数据，如果工作内存中不存在，则从主内存中拷贝一份数据到工作内存中；写操作只会修改工作内存的副本数据，这种情况下，其它线程就无法读取变量的最新值。
2. 对于volatile变量，读操作时JMM会把工作内存中对应的值设为无效，要求线程从主内存中读取数据；写操作时JMM会把工作内存中对应的数据刷新到主内存中，这种情况下，其它线程就可以读取变量的最新值。

volatile变量的内存可见性是基于内存屏障(Memory Barrier)实现的，什么是内存屏障？内存屏障，又称内存栅栏，是一个CPU指令。在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM为了保证在不同的编译器和CPU上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和CPU：不管什么指令都不能和这条Memory Barrier指令重排序。

```
instance = new Singleton(); //instance是volatile变量
```

转变为汇编语言

![](Volatile关键字/volatile1.png)

可以看到有有一个Lock前缀指令，相当于上述的内存屏障该指令，在多核处理器下会引发两件事：

1. 将当前处理器缓存行的数据写回到系统内存
2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

为了提高处理速度，处理器不直接和内存进行通信，而是将系统内存的数据读到内部缓存(L1,L2或其他)后再操作，但操作完不知道何时写到内存。如果对声明了volatile的变量进行写操作，JVM会向处理器发送一条Lock前缀指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器的缓存值仍然是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存一致，就会实现缓存一致性协议，每个处理器通过嗅探在总线上的数据来检查自己的缓存的值是不是过期了，当处理器发现自己缓存行的对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改的时候，会重新从系统内存中把数据读到处理器缓存里。


volatile变量很方便，但也存在一些局限性。volatile通常用作某个操作完成、发生中断或者状态的标志，但比如在做递增操作(count++)时，volatile不足以确保原子性，除非能保证只有一个线程对变量执行写操作。

> 加锁机制既可以确保可见性又可以确保原子性，volatile只能确保可见性

当且仅当满足以下条件时，才使用volatile变量

1. 对变量的写入操作不依赖变量的当前值，或者能确保只有一个线程更新变量的值，如多线程下执行a++，是无法通过volatile保证结果准确性的
2. 该变量不会与其他状态变量一起纳入不变性条件中
3. 在访问时不用加锁


推荐阅读：[占小狼博客](https://www.jianshu.com/p/506c1e38a922)